package main

func ProcessPaymentMasterCard(mcp masterCardPayment, amount float64) (string, error) {
	return mcp.PayByMasterCard(amount)
}

func ProcessPaymentVisa(vp visaPayment, amount float64) (string, error) {
	return vp.PaByVisa(amount)
}


Мы могли бы пойти вот таким путём: наплодить кучу отдельных функций, которые были бы завязаны на конкретные структуры.
То есть каждая из processPaymentMasterCard и processPaymentVisa зависела бы от конкретной, не абстрактной реализации конкретной структуры.
В нашем примере мы сразу проскочили этот этап и сделали всё по уму.

Мы захотели сделать наш код открытым для расширения и закрытым для изменения в соответствии с
SOLID → мы применили паттерн «Стратегия» → паттерн «Стратегия» буквально основывается на принципе
инверсии зависимостей из SOLID → а сама инверсия зависимостей тесно связана с внедрением зависимости
(Dependency Injection).

Dependency Injection, вы можете увидеть сам процесс внедрения в теле функции main.
Там мы инициализируем наши структуры и передаём их внутрь processPayment — это и есть те самые
внедряемые зависимости, которые ждёт эта функция. Внедрение зависимости в общем случае — штука
довольно банальная. К примеру, в том же функциональном программировании само это понятие даже
избыточно, так как там функции повсеместно принимают другие функции в качестве аргументов, что
по сути и является тем же Dependency Injection.


func ProcessPaymentMasterCard(mcp masterCardPayment, amount float64) (string, error) {
	return mcp.PayByMasterCard(amount)
}

func ProcessPaymentVisa(vp visaPayment, amount float64) (string, error) {
	return vp.PaByVisa(amount)
}

// Мы могли бы пойти вот таким путём: наплодить кучу отдельных функций,
// которые были бы завязаны на конкретные структуры.
// То есть каждая из processPaymentMasterCard и processPaymentVisa
// зависела бы от конкретной, не абстрактной реализации конкретной структуры.

// Мы захотели сделать наш код открытым для расширения и закрытым для
// изменения в соответствии с SOLID → мы применили паттерн «Стратегия»
// → паттерн «Стратегия» буквально основывается на принципе инверсии
// зависимостей из SOLID → а сама инверсия зависимостей тесно связана
// с внедрением зависимости (Dependency Injection)

// Говоря о Dependency Injection, вы можете увидеть сам процесс внедрения
// в теле функции main. Там мы инициализируем наши структуры и передаём их
// внутрь processPayment — это и есть те самые внедряемые зависимости,
// которые ждёт эта функция. Внедрение зависимости в общем случае — штука
// довольно банальная. К примеру, в том же функциональном программировании
// само это понятие даже избыточно, так как там функции повсеместно принимают
// другие функции в качестве аргументов, что по сути и является тем же
// Dependency Injection.