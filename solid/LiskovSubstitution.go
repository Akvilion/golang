Давайте простым языком и на наших примерах. Мы с вами создали VisaPayment, MasterCardPayment, PaypalPayment.
Это всё буквально типы. Те самые «некоторые типы» из определения выше. И интерфейс Payer — это тоже тип.

Принцип подстановки Лисков говорит нам о том, что если какой-то тип является родительским для другого, то там,
где используется родительский тип, мы всегда можем подставить дочерний тип, и всё продолжит работать так, как есть.


func ProcessPayment(p Payer, amount float64) (string, error) {
	return p.Pay(amount)
}


Каждая из этих функций ожидает, чтобы ей был передан конкретный экземпляр конкретной структуры.
И даже если оба экземпляра будут иметь одинаковые поля, закреплённые за ними методы, то мы не
сможем передать один вместо другого, если они не созданы от одной и той же структуры. ProcessPaymentVisa
не примет MasterCardPayment, как бы мы ни старались.

func ProcessPaymentMasterCard(mcp masterCardPayment, amount float64) (string, error) {
	return mcp.PayByMasterCard(amount)
}

func ProcessPaymentVisa(vp visaPayment, amount float64) (string, error) {
	return vp.PaByVisa(amount)
}

Структурная типизация фокусируется на внутренней структуре объекта. Если бы в Go типизация структур была структурной,
то не важно было бы, от какой изначальной структуры создаётся экземпляр. Принимающая сторона, например, ProcessPaymentVisa,
просто проверяла бы наличие всех необходимых полей и методов в экземпляре. Этого было бы достаточно для корректной работы.

В Go структурная типизация как раз у интерфейсов. То есть когда мы объявляем интерфейс PaymentMethod,
то нам становится интересно только наличие всех необходимых методов у того, что мы передадим в ProcessPayment

утиная типизация, которая распространена в динамических языках программирования, является частным случаем структурной типизации,
когда проверка соответствия структуры требованиям вызывающего кода выносится на этап исполнения программы, а не на этап компиляции,
как в Go. В динамическом языке с утиной типизацией интерпретатор промолчал бы, что у структуры нет метода Pay, когда мы передавали
бы её в функцию. Просто на этапе исполнения этот метод попытался бы быть вызван, и вылетела бы ошибка

номинальная типизация подтипов
В Go он не водится. В простом объяснении через наследование в других языках: номинальная типизация подтипов позволяет нам использовать
класс-потомок вместо родителя. Если у нас есть класс Animal и мы на его базе создали класс Dog, то любой код, который номинально ждёт
экземпляр класса Animal, примет и экземпляр класса Dog. Так как при наследовании мы явно указываем, что Dog это наследник Animal и по
сути является его подтипом


Мы не имеем механизма сказать, что какая-то структура является дочерней для другой структуры.
Встраивание структуры в структуру не создаёт иерархии типов. И как раз в этот момент становится
особенно очевидно, что в Go нет наследования. Всякий раз, когда изучение Go сопровождается
терминологией «тут мы наследуем структуру А от структуры В», это больше вредит пониманию сути
вещей, чем помогает. В Go есть только композиция, и у этого есть свои чёткие свойства, которые
отличны от принципов наследования.

