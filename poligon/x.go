package main

import (
	"fmt"
	"sync"
)

// Пояснення запису cs ...<-chan int
// cs — це ім'я параметра (змінна).
// ... — це варіативний параметр, що дозволяє передавати довільну кількість аргументів одного типу.
// <-chan int — це тип кожного аргументу, а саме канал для читання з типом int.

func merge(cs ...<-chan int) <-chan int {
	out := make(chan int)

	go func() {
		wg := &sync.WaitGroup{}
		wg.Add(len(cs))
		for _, ch := range cs {
			go func(ch <-chan int) {
				defer wg.Done()
				for v := range ch {
					out <- v
				}
			}(ch)
		}
		wg.Wait()
		close(out)
	}()
	return out
}

func main() {
	ch1 := make(chan int, 2)
	ch2 := make(chan int)

	out := merge(ch1, ch2)

	go func() {
		ch1 <- 1
		ch1 <- 2
		close(ch1)
	}()

	go func() {
		ch2 <- 3
		close(ch2)
	}()

	for val := range out {
		fmt.Println(val)
	}

}

// Цей код на Go демонструє використання `defer`, структури та методів:

// 1. **Структура `X`**:
//    - Визначено структуру `X` з одним полем `V`, яке є типом `int`.

// 2. **Метод `S` для `X`**:
//    - Метод `S` визначений для типу `X` і виводить значення поля `V` в консоль.

// 3. **Функція `main`**:
//    - Створюється змінна `x` типу `X` зі значенням `V` рівним `123`.
//    - Далі викликається метод `S` через `defer`. Це означає, що виклик методу `S` буде відкладено до моменту, коли функція `main` завершиться.
//    - Після цього змінюється значення поля `V` в `x` на `456`.

// ### Що відбувається:
// - Коли функція `main` завершується, викликається відкладена функція `x.S()`. Але важливо те, що Go передає значення для методів за **копією**. У цьому випадку `x.S()` отримає копію об'єкта `x` на момент, коли був виконаний оператор `defer`, тобто коли `V` ще було рівне `123`.
// - Тому при виклику методу `S`, буде виведено значення `123`, незважаючи на те, що пізніше значення `V` змінюється на `456`.

// ### Вивід:
// У результаті виконання цього коду в консоль буде виведено:
// ```
// 123
// ```

// #### Причина:
// Це відбувається через копіювання значення змінної `x` на момент виклику `defer`.
