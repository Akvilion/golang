WIN
set GOPATH="C:\code"

UNIX
export GOPATH="/code"

go clean -modcache

go mod tidy

go get ____________

go mod init xxx

godoc -http=:6060  # сервер з документацією локальний
http://localhost:6060/pkg


По умолчанию рабочей областью является каталог
с именем go в домашнем каталоге пользователя.

Чтобы использовать в качестве рабочей обла-
сти другой каталог, настройте переменную среды
GOPATH

GOROOT вказує на розташування компілятора та стандартної бібліотеки
GOPATH визначає місце розташування вашого проекту Go та сторонніх бібліотек

За умовчанням GOPATH встановлено на $HOME/go
Встановіть GOPATH для цього проекту
echo 'export GOPATH=~/my_go_project' >> ~/.bashrc
source ~/.bashrc
echo 'export GOPATH=~/my_go_project' >> ~/.zshrc
source ~/.zshrc
go mod init my_project
Тепер ваш проект ізольований у власному GOPATH,
і всі пакети та залежності будуть зберігатися у
цьому каталозі. Коли ви будете компілювати або
виконувати ваш проект, Go буде використовувати
цей ізольований GOPATH.

Якщо у нас 2 проети то щоб розділити GOPATH для них можна використоаувати
direnv


Команда go install компилирует код пакета
и сохраняет его в каталоге pkg для пакетов общего
назначения или в каталоге bin для исполняемых
программ.

go install average
скомпілює наш main.go файл і закине його в папку bin
C:\Users\codeo\go\bin
Потім ми його можемо запустити з cmd
PS C:\Users\codeo\go\bin> .\average.exe
72.5


загон з шляхами
C:\Projects\golang\src\github.com\headfirstgo\average\main.go
в тому файлику була лінійка
numbers, err := datafile.GetFloats("C:/Projects/golang/src/github.com/headfirstgo/datafile/data.txt")
Я вписав абсолютний шлях
тому що коли робиш go install src/github.com/headfirstgo/average 
воно створювало exe файл в C:\Users\codeo\go\bin
і коли запускав його воно викидувало 2024/04/13 16:58:12 open ../datafile/data.txt: The system cannot find the path specified.
воно походу шукало data.txt на відносно того exe файлу ../datafile/data.txt
тобто раз вгору там datafile/data.txt
тому вписав абсолютний шлях

щоб використати slice заміть змінної кількості артгументів потрібно ...
func average(numbers ...float64) float64 {}
var numbers []float64
average(numbers...)

аналог dict в go
var ranks map[string]int  // оголошення //string - ключи,  int - значення
ranks := make(map[string]int)  // створення
myMap := map[string]float64{"a": 1.2, "b": 5.6}  // якщо літерат то make не треба

Якщо map оголошена але не створена то неможливо добавити якесь значення
var myMap map[int]string = make(map[int]string)
myMap[3] = "three"
А отак можливо

Якщо значення в мапі оголошене 0, а не присвоїне, то ok буде повертати false
counters := map[string]int{"a": 3, "b": 0}
value, ok := counters["a"]  // 3, true
value, ok := counters["c"]  // 0, false // звернення до відсутнього значення
_, ok = counters["f"] // перевірка на наявність значення

Видалення ключа
ranks := make(map[string]int)
ranks["bronze"] = 3
delete(ranks, "bronze")

map в go невпорядкований
тобто при ітерації церез map 
друкує кожен раз в різному порядку

якщо функція нічого не повертає, але треба модифікувати оригінальні дані 
то треба використовувати вказівники
а якщо функція повертає дані то не потрібні вказівники

fmt.Printf("%#v\n", subscriber.HomeAddress)
"%#v\n" виводить оригінальний вигляд
так як записано в коді
наприклад не пусте місце а пуста строка ""
але потрібно використовувати Printf а не Println

Якщо є анонімне поле
type Adress strunc {
    street string
}
type people struc {
    Adress
}
то можна упустити Adress при доступі до полів
а звертатись до street з people
people.street

Методи
тип це аналог класу в пітоні
тип параметра отримувача є типом з яким зв`язується Методи
type Words string
func (w Words) sayWords () {
    fmtw.Println(w)
}
a := Words("hello")
a.sayWords()
// w - параметр отримувача

w ім`я отримувача має бути першою буквою типу Words

Якщо є структура то її літерал буде з {}
coordinates := geo.Coordinates{}

В go дані інкапсулюються в пакетах
за допомогою неімпортованих імен (з малої букви)

якщо є структура з вбудованим типом
type MyStruct string
то вона викликається через круглі дужки
MyStruct("fffff")

defer запускає код в кінці виконання

Якщо немає panic то defer повертає nil
p := recover()
if p == nil {
    return
}

обробник паніки
func reportPanic() {
	p := recover()
	if p == nil {
		return
	}
	err, ok := p.(error)
	if ok {
		fmt.Println(err)
	} else {
		panic(p)
	}
}

справка по командах
go doc http Get
go doc http Response
go doc io ReadCloser
go doc ioutil ReadAll

створювалорення каналу
channelA := make(chan int)

Створити list
urls := []string{"https://example.com/", "https://golang.org/", "https://golang.org/doc"}


x:=[2]string{"one", "two"} vs x:=[]string{"one", "two"}
Passing to Functions: When you pass an array to a function, a copy of the entire array is made.
In contrast, passing a slice to a function only passes a reference to the underlying array,
which is more efficient for large data sets.

тести
якщо тести будуть в пакеті з кодом, то будуть мати доступ до неекспортуємих функцій
імена тестів повинні починатись з Test
тестові функції повинні мати 1 параметр (t *testing.T)

щоб тести запускались файл має називатись
_test.go
і тоді запуск через папку, а не через файл

go test .\compare\ -v
розширений вивід
go test .\compare\ -v -run First
запустить тести тільки ті які мають в імені First

Змінна типу функції
func sayHi() { fmt.Println("Hi") }
var myFunction func()
myFunction = sayHi
myFunction()

Якщо оголошуємо зміну з типом func()
то має бути точна кількість параметрів
var mathFunction func(int, int) float64
func divide(a int, b int) float64 { return float64(a) / float64(b) }
mathFunction = divide
mathFunction(5, 2)
не вийде покласти в mathFunction sayHi
func sayHi() { fmt.Println("Hi") }

func doMath(passedFunction func(int, int) float64) {
	result := passedFunction(10, 2) fmt.Println(result)
	}
func multiply(a int, b int) float64 { return float64(a * b) }
doMath(divide)
doMath(multiply)
вказуємо що doMath першим параметром отримує func з 2ма параметрами

Побітовий оператор &
0 & 0 == 0
0 & 1 == 0
1 & 1 == 1
fmt.Printf("%02b\n", 1)    // 10
fmt.Printf("%02b\n", 3)    // 11
fmt.Printf("%02b\n", 1&3)  // 01
Побітовий оператор ||
0 | 0 == 0
0 | 1 == 1
1 | 1 == 1
fmt.Printf("%02b\n", 2)    // 10
fmt.Printf("%02b\n", 0)    // 00
fmt.Printf("%02b\n", 2|0)  // 10
--------------------------------
fmt.Printf("%016b\n", os.O_RDONLY)     //  0000000000000000
fmt.Printf("%016b\n", os.O_WRONLY)     //  0000000000000001
fmt.Printf("%016b\n", os.O_RDWR)       //  0000000000000010
fmt.Printf("%016b\n", os.O_CREATE)     //  0000000001000000
fmt.Printf("%016b\n", os.O_APPEND)     //  0000010000000000
--------------------------------
fmt.Printf("%016b\n", os.O_WRONLY|os.O_CREATE)               //  0000000001000001
fmt.Printf("%016b\n", os.O_WRONLY|os.O_CREATE|os.O_APPEND)   //  0000010001000001

fmt.Println(os.FileMode(0700))
fmt.Println(os.FileMode(0070))
fmt.Println(os.FileMode(0007))
-rwx------  // власник файлу
----rwx---  // користувачі з групи
-------rwx  // всі інші
0    Разрешения отсутствуют
1    Исполнение
2    Запись
3    Запись, исполнение
4    Чтение
5    Чтение, исполнение
6    Запись, чтение
7    Запись, чтение, исполнение

if count := 5; count > 4 {
	fmt.Println("count is", count)
}

Если же вы хотите, чтобы после текущей секции
case выполнялся код следующей, для этого существу-
ет ключевое слово fallthrough

Если вас интересует длина строки в символах, используйте функцию
RuneCountInString из пакета unicode/utf8
fmt.Println(utf8.RuneCountInString(asciiString))
fmt.Println(utf8.RuneCountInString(utf8String))

channel := make(chan string, 3)
Когда горутина отправляет значение в небуферизованный канал, она немедленно
блокируется до того, как значение будет получено другой горутиной. С другой
стороны, буферизованные каналы могут вмещать определенное количество зна-
чений, прежде чем отправляющая горутина будет заблокирована. В подходящей
ситуации это может улучшить быстродействие программы.

channel := make(chan string, 2)
Чтобы немного ускорить выполнение программы, можно добавить в канал буфера еще одно значение.
Для этого достаточно добавить второй аргумент при вызове make. В остальном взаимодействия с
каналом остаются неизменными, так что вносить другие изменения в код не придется.
Теперь когда горутина sendLetters отправит свое первое значение в канал, она не блокируется
до того момента, как это значение будет получено горутиной main. Отправленное значение вместо
этого попадает в буфер канала. Только при отправке второго значения (при том, что ни одного
значения еще не было получено) буфер канала заполняется, а горутина sendLetters блокируется.
Добавление буфера, рассчитанного на одно значение, сокращает время выполнения программы на 1 секунду.


Функция init выполняется при инициализации пакета


пакет (файл) redis імпортується в пакет (файл) main.
значить перше виконається init() в redis потім init() в main


щоб ініціалізувати пакет (файл) без імпорту з нього, потрібно вписати _
import (
"fmt"
_ "foo"
)


Інтерфейсти відділяють код від його реалізації
Якщо ми покладаємось на абстрацію, замість конкретної реалізації, то сама реалізація може бути замінена на іншу без заміни коду.
Це і є принцип Лісков


краше повертати з функцій конкретні реалізації а не інтерефейси


Щоб написати функцію в го яка приймає любий тип потрібно використати пустий Інтерфейс
func printValue(v interface{}) {
    fmt.Println(v)
}


Ключем в map в го може бути тип який можна порівнювати за допомогою операторів рівності (== і !=)
Це означає, що типи, які задовольняють обмеженню comparable, можуть бути використані як ключі в мапах
Типи, які є comparable:
	Всі базові типи, такі як int, float, string, bool.
	Вказівники.
	Масиви, якщо їх елементи є comparable.
	Структури, якщо всі їх поля є comparable.
Типи, які не є comparable:
	Слайси.
	Мапи.
	Функції.


Дженерік
func foo[T any](t T) {
    fmt.Println(t)
}
func main() {
    foo(42) // T буде визначено як int
}
Отже, [T any] визначає, що T може бути будь-яким типом, і дозволяє функції foo приймати аргументи будь-якого типу.


Якщо функція має приймати map яка може мати любі типи, то тоді треба дженерів для K,V
func getKeys[K comparable, V any](m map[K]V) []K {
    var keys []K
    for k := range m {
        keys = append(keys, k)
    }
    return keys
}


x := map[int]string{1: "one", 2: "two"}
==
var x map[int]string
x = map[int]string{1: "one", 2: "two"}


кастомний тип замість constrain
type customConstraint interface {
	~int | ~string
}
func getKeys[K customConstraint, V any](m map[K]V) []K {
	// Та же реализация
}


constraint
~int і int?
~int ограничивает все типы, базовым типом которых является int


Як добавити обмеження типу
func constrainMe interface {
	~int   // всі пити базовим типом яких є int
	String() string    // реалізує метод String()
}
type customInt int  // значить це відповідає інтерфейсу constrainMe
func (i customInt) String() string {  // тут ми реалізуємо тип String() який повертає рядок
	return strconv.Itoa(int(i))
}
У підсумку, тип customInt реалізує інтерфейс constrainMe, оскільки він:
Сумісний з типом int (оскільки це новий тип на основі int).
Має метод String(), який повертає рядок.


Дженерики вводят некоторую форму абстракции
якось до того жили без них


type Foo struct {
	Bar  // Встроенное поле
}
type Bar struct {
	Baz int
}
foo := Foo{}
foo.Baz = 42
Якщо поле вбудоване то до нього буде доступ ззовні
Щоб поле було заблоковано ззовні потрібно вказати тип


Параметри функцій
Go не підтримує параметри за замовчуванням, але є способи
///////////////////////////////////////////////////////////
func One(name string, message ...string){
	defaultMessage := "hello"
	if len(message) == 0 {
		fmt.Println("%s, %s!\n", defaultMessage, name)
	}
}
///////////////////////////////////////////////////////////
type One struct {
	name string
	age int
}

func X() *One{
	return &One{name: "Taras", age: 16}
}
func greetWithConfig(cfg *One) {
    fmt.Printf("%s, %s!\n", cfg.name, cfg.age)
}
func main() {
	a:= X()
	greetWithConfig(a)
}


Оператор * використовується для доступу до значення за адресою (розіменування вказівника)
Оператор & використовується для отримання адреси змінної (створення вказівника)


Структура проекту го
/cmd — основные исходные файлы. Файл main.go приложения foo должен находиться в /cmd/foo/main.go.
/internal — закрытый (private) код: мы не хотим, чтобы другие импортировалиего для своих приложений или библиотек
/pkg — общедоступный (public) код, который мы хотим предоставлять другим в пользование.
/test — дополнительные внешние тесты и тестовые данные
/configs — файлы конфигурации.
/docs — проектные и пользовательские документы
/examples — примеры для нашего приложения и/или общедоступной библиотеки
/api — файлы контрактов API (Swagger, Protocol Buffers и т. д.)
/web — ресурсы, относящиеся к веб-приложению (статические файлы и т. д.).
/build — файлы упаковки и непрерывной интеграции (CI).
/scripts — скрипты для анализа, установки и т. д.
/vendor — зависимости приложений (например, зависимости модулей Go)


Варіантивна кількість параметрів
func greet(name string, messages ...string) {
    for _, message := range messages {
        fmt.Printf("%s, %s!\n", message, name)
    }
}
greet("Alice", "Hello", "Welcome", "Good to see you")
...string: Дозволяє передавати довільну кількість аргументів без необхідності створювати зріз.
[]string: Потребує створення зрізу перед передачею у функцію.


sum := 100 + 010
fmt.Println(sum)
В го (010) литерал, начинающийся с 0, считается восьмеричным
целым числом (то есть числом по основанию 8), поэтому 10 по основанию 8
равняется 8 по основанию 10. Таким образом, сумма в предыдущем примере
равна 100 + 8 = 108
Щоб відділити можна так 
0o644


int8: от -128 до 127
int16: от -32768 до 32767
int32: от -2147483648 до 2147483647
int64: от -9223372036854775808 до 9223372036854775807
int: размер зависит от архитектуры (обычно 32 или 64 бита)
uint8: от 0 до 255
uint16: от 0 до 65535
uint32: от 0 до 4294967295
uint64: от 0 до 18446744073709551615
uint: размер зависит от архитектуры (обычно 32 или 64 бита)
Если нужно проверить на переполнение переменную
типа int, можно сделать это с помощью math.MaxIntі


Python автоматично переходить з використання звичайних цілих чисел (зазвичай 32 або 64 біти)
на використання довгих цілих чисел (arbitrary-precision integers)
Python є мовою з динамічною типізацією, що означає, що типи змінних визначаються під час виконання,
а не під час компіляції. Це дозволяє Python автоматично змінювати тип змінної з int на long (у Python 2)
або використовувати єдиний int тип (у Python 3), який підтримує довгі цілі числа.


IEEE-754, NaN — единственное число с плавающей точкой, удовлетворяющее условию f ! = f.


Go-разработчики довольно часто путают понятия длины среза и его емкости
В Go за срезом стоит массив
Длина — это количество элементов, содержащихся в срезе, тогда
как емкость — это количество элементов в резервном массиве.
s := make([]int, 3, 6)
Срез длиной 3 и емкостью 6
В данном случае make создает массив из шести элементов (емкость). Но посколь-
ку длина среза была задана равной 3, то Go инициализирует только первые три
элемента. Кроме того, поскольку срез является типом []int, первые три элемента
инициализируются нулевым значением int: 0. Для элементов, обозначенных
серым цветом, память зарезервирована, но они пока не используются.
Как использовать оставшееся пространство среза? С помощью встроенной
функции append:
s = append(s, 2)
В Go размер среза будет удваиваться до тех пор, пока
он не станет содержать 1024 элемента, после чего будет увеличиваться
на 25 %.
Go внутри себя создает другой массив, удваивая его емкость
и копируя в него все элементы, а затем вставляет новий элемент


s1 := make([]int, 3, 6)
s2 := s1[1:3]
Срезы s1 и s2 ссылаются на один и тот
же резервный массив, но с разной длиной
и емкостью

Поскольку за s1 и s2
стоит один и тот же массив,
обновление общего элемента
делает изменение видимым
в обоих срезах

s: [0 0 0], len: 3, cap: 5
s: [0 0 0 1], len: 4, cap: 5
s: [0 0 0 1 2], len: 5, cap: 5
s: [0 0 0 1 2 3], len: 6, cap: 10
В начале мы создаем срез s с длиной 3 и емкостью 5.
Емкость 5 означает, что срез может содержать до 5 элементов без перераспределения памяти.
Когда мы добавляем четвертый и пятый элементы, длина увеличивается, но емкость остается прежней.
Когда мы добавляем шестой элемент, текущая емкость (5) превышена, и Go перераспределяет память,
удваивая емкость до 10, чтобы вместить дополнительные элементы.


Длина среза — это количество доступных элементов в нем, 
емкость среза — это количество элементов в резервном массиве
Якщо ми задаємо ємність то при добавленні нових елементів не будуть створюватись резервні Масиви



Срез считается пустым, если его длина равна 0.
Срез считается нулевым, если его значение равно nil.
варіанти створення зрізів
var s []string
s = []string(nil)
s = []string{}
s = make([]string, 0)
1: empty=true nil=true
2: empty=true nil=true
3: empty=true nil=false
4: empty=true nil=false
Здесь нулевой срез маршалируется как элемент null,
тогда как ненулевой пустой срез маршалируется как пустой массив
Нулевой срез равен nil, тогда как пустой срез имеет нулевую длину.
Нулевой срез пуст, но пустой срез не обязательно равен nil.


var s []string, если нет определенности в отношении конечной длины и срез
может быть пустым


[]string(nil) как синтаксический сахар для создания нулевого и пустого
среза.


make([]string, length), если будущая длина известна.


Найправильніший спосіб перевірити чи зріз чи він пустий чи нульовий це len


Як копіювати один зріз в другий
src := []int{0, 1, 2}
var dst []int
copy(dst, src)
fmt.Println(dst)  // []  вийде пустий зріз тому що dst має довжину 0. А при copy береться найменше з (3 i 0)


Як копійнути правильно
src := []int{0, 1, 2}
dst := make([]int, len(src))
copy(dst, src)
Альтернатива copy
src := []int{0, 1, 2}
dst := append([]int(nil), src...)


Якщо в нас є зріз на 1млн елементів а ми хочемо показувати тільки останні 5, то потрібно
msgType := make([]byte, 5)
copy(msgType, msg)
Але все таки повний зріз теж не можна брати бо вихідний масив все ще буде в пам'яті
 качестве эмпирического правила запомните, что нарезка большого среза
или массива может потенциально привести к высокому потреблению памяти
Использование копии среза — это
способ предотвращения такой ситуации



как работают операторы == и !=. Со срезами или картами они не работают вообще
можно использовать Reflect.DeepEqual
Эта функция сообщает, являются ли два элемента глубоко равными (deeply equal),
рекурсивно обходя два значения
Reflect.DeepEqual примерно в 100 раз медленнее, чем ==

accounts := []account{
{balance: 100.},
{balance: 200.},
{balance: 300.},
}
	for _, a := range accounts {
		a.balance += 1000  // не обновить значення тому що створюються копії
}
for i := range accounts {
	accounts[i].balance += 1000  // обновить значення нормально
}
for i := 0; i < len(accounts); i++ {
	accounts[i].balance += 1000  // обновить значення нормально
}




карти
m := make(map[string]int, 1_000_000)
Створення дікта на 1млн елементів
Якщо вставити 1млн ел в карту без розміру і з розміром заданим
То останінй варіант буде на 60% швидший



Якщо створити карту добавити 1 млн ел, а потім видалити їх
То память не очиститься в нуль так як сегменти залишаться
При видалені елементів обнуляються слоти в сегментах, але самих сегментів не стає менше


Якщо створити карту через вказівники масиву
                        					map[int][128]byte vs map[int]*[128]byte
Создание пустой карты                              0                    0
Добавление 1 миллиона элементов                    461mb               182mb
Удаление всех элементов и исполнение GC           293mb                 38mb


Если ключ или значение превышает 128 байт, Go не будет
хранить их непосредственно в сегменте карты. Вместо этого хранится указа-
тель — для ссылки на ключ или на значение.


map[int][128]byte:
Це карта, де кожен ключ (типу int) мапується на значення типу [128]byte.
Всі значення зберігаються в самій мапі.
Коли ви додаєте або змінюєте елемент у мапі, Go копіює всі 128 байт.


map[int]*[128]byte:
Це карта, де кожен ключ мапується на вказівник (pointer) на масив з 128 байтів.
Вказівники на масиви зберігаються в мапі, а самі масиви знаходяться в пам'яті.
Це економить місце у мапі, оскільки зберігаються лише вказівники (по 8 байт на 64-бітових системах).
Копіювання значень займає менше часу, оскільки копіюються лише вказівники, а не самі дані масивів.


Зберігання вказівника займає 8 байт на 64 і 4 байта на 32


s := []int{0, 1, 2}
for range s {
	s = append(s, 10)
}
такий цикл завершиться після 3х ітерацій
В этом контексте слово «вычисляется» означает, что предоставленное выражение
копируется во временную переменную, а затем цикл range выполняет итерации
над этой переменной.



s := []int{0, 1, 2}
for i := 0; i < len(s); i++ {
	s = append(s, 10)
}
Значение выражения len(s) вы-
числяется во время каждой итерации, и раз мы продолжаем добавлять элемен-
ты, то никогда не достигнем состояния завершения цикла


& (Оператор взяття адреси):
Оператор & використовується для отримання адреси змінної
* (Оператор розіменування):
Оператор * використовується для доступу до значення за адресою



Щоб зробити параметри який може бути або string або nill потрнібно використовувати вказівник на string
func processString(s *string) {
	if s == nil {
		fmt.Println("Received nil")
	} else {
		fmt.Println("Received string:", *s)
	}
}
func main() {
	str := "Hello, Go!"
	var nilStr *string = nil

	processString(&str)  // Passing a string
	processString(nilStr) // Passing nil
}