WIN
set GOPATH="C:\code"

UNIX
export GOPATH="/code"

go clean -modcache

go mod tidy

go get ____________

go mod init xxx

godoc -http=:6060  # сервер з документацією локальний
http://localhost:6060/pkg


По умолчанию рабочей областью является каталог
с именем go в домашнем каталоге пользователя.

Чтобы использовать в качестве рабочей обла-
сти другой каталог, настройте переменную среды
GOPATH

GOROOT вказує на розташування компілятора та стандартної бібліотеки
GOPATH визначає місце розташування вашого проекту Go та сторонніх бібліотек

За умовчанням GOPATH встановлено на $HOME/go
Встановіть GOPATH для цього проекту
echo 'export GOPATH=~/my_go_project' >> ~/.bashrc
source ~/.bashrc
echo 'export GOPATH=~/my_go_project' >> ~/.zshrc
source ~/.zshrc
go mod init my_project
Тепер ваш проект ізольований у власному GOPATH,
і всі пакети та залежності будуть зберігатися у
цьому каталозі. Коли ви будете компілювати або
виконувати ваш проект, Go буде використовувати
цей ізольований GOPATH.

Якщо у нас 2 проети то щоб розділити GOPATH для них можна використоаувати
direnv


Команда go install компилирует код пакета
и сохраняет его в каталоге pkg для пакетов общего
назначения или в каталоге bin для исполняемых
программ.

go install average
скомпілює наш main.go файл і закине його в папку bin
C:\Users\codeo\go\bin
Потім ми його можемо запустити з cmd
PS C:\Users\codeo\go\bin> .\average.exe
72.5


загон з шляхами
C:\Projects\golang\src\github.com\headfirstgo\average\main.go
в тому файлику була лінійка
numbers, err := datafile.GetFloats("C:/Projects/golang/src/github.com/headfirstgo/datafile/data.txt")
Я вписав абсолютний шлях
тому що коли робиш go install src/github.com/headfirstgo/average 
воно створювало exe файл в C:\Users\codeo\go\bin
і коли запускав його воно викидувало 2024/04/13 16:58:12 open ../datafile/data.txt: The system cannot find the path specified.
воно походу шукало data.txt на відносно того exe файлу ../datafile/data.txt
тобто раз вгору там datafile/data.txt
тому вписав абсолютний шлях

щоб використати slice заміть змінної кількості артгументів потрібно ...
func average(numbers ...float64) float64 {}
var numbers []float64
average(numbers...)

аналог dict в go
var ranks map[string]int  // оголошення //string - ключи,  int - значення
ranks := make(map[string]int)  // створення
myMap := map[string]float64{"a": 1.2, "b": 5.6}  // якщо літерат то make не треба

Якщо map оголошена але не створена то неможливо добавити якесь значення
var myMap map[int]string = make(map[int]string)
myMap[3] = "three"
А отак можливо

Якщо значення в мапі оголошене 0, а не присвоїне, то ok буде повертати false
counters := map[string]int{"a": 3, "b": 0}
value, ok := counters["a"]  // 3, true
value, ok := counters["c"]  // 0, false // звернення до відсутнього значення
_, ok = counters["f"] // перевірка на наявність значення

Видалення ключа
ranks := make(map[string]int)
ranks["bronze"] = 3
delete(ranks, "bronze")

map в go невпорядкований
тобто при ітерації церез map 
друкує кожен раз в різному порядку

якщо функція нічого не повертає, але треба модифікувати оригінальні дані 
то треба використовувати вказівники
а якщо функція повертає дані то не потрібні вказівники

fmt.Printf("%#v\n", subscriber.HomeAddress)
"%#v\n" виводить оригінальний вигляд
так як записано в коді
наприклад не пусте місце а пуста строка ""
але потрібно використовувати Printf а не Println

Якщо є анонімне поле
type Adress strunc {
    street string
}
type people struc {
    Adress
}
то можна упустити Adress при доступі до полів
а звертатись до street з people
people.street

Методи
тип це аналог класу в пітоні
тип параметра отримувача є типом з яким зв`язується Методи
type Words string
func (w Words) sayWords () {
    fmtw.Println(w)
}
a := Words("hello")
a.sayWords()
// w - параметр отримувача

w ім`я отримувача має бути першою буквою типу Words

Якщо є структура то її літерал буде з {}
coordinates := geo.Coordinates{}

В go дані інкапсулюються в пакетах
за допомогою неімпортованих імен (з малої букви)

якщо є структура з вбудованим типом
type MyStruct string
то вона викликається через круглі дужки
MyStruct("fffff")

defer запускає код в кінці виконання

Якщо немає panic то defer повертає nil
p := recover()
if p == nil {
    return
}

обробник паніки
func reportPanic() {
	p := recover()
	if p == nil {
		return
	}
	err, ok := p.(error)
	if ok {
		fmt.Println(err)
	} else {
		panic(p)
	}
}

справка по командах
go doc http Get
go doc http Response
go doc io ReadCloser
go doc ioutil ReadAll

створювалорення каналу
channelA := make(chan int)

Створити list
urls := []string{"https://example.com/", "https://golang.org/", "https://golang.org/doc"}


x:=[2]string{"one", "two"} vs x:=[]string{"one", "two"}
Passing to Functions: When you pass an array to a function, a copy of the entire array is made.
In contrast, passing a slice to a function only passes a reference to the underlying array,
which is more efficient for large data sets.

тести
якщо тести будуть в пакеті з кодом, то будуть мати доступ до неекспортуємих функцій
імена тестів повинні починатись з Test
тестові функції повинні мати 1 параметр (t *testing.T)

щоб тести запускались файл має називатись
_test.go
і тоді запуск через папку, а не через файл

go test .\compare\ -v
розширений вивід
go test .\compare\ -v -run First
запустить тести тільки ті які мають в імені First

Змінна типу функції
func sayHi() { fmt.Println("Hi") }
var myFunction func()
myFunction = sayHi
myFunction()

Якщо оголошуємо зміну з типом func()
то має бути точна кількість параметрів
var mathFunction func(int, int) float64
func divide(a int, b int) float64 { return float64(a) / float64(b) }
mathFunction = divide
mathFunction(5, 2)
не вийде покласти в mathFunction sayHi
func sayHi() { fmt.Println("Hi") }

func doMath(passedFunction func(int, int) float64) {
	result := passedFunction(10, 2) fmt.Println(result)
	}
func multiply(a int, b int) float64 { return float64(a * b) }
doMath(divide)
doMath(multiply)
вказуємо що doMath першим параметром отримує func з 2ма параметрами

Побітовий оператор &
0 & 0 == 0
0 & 1 == 0
1 & 1 == 1
fmt.Printf("%02b\n", 1)    // 10
fmt.Printf("%02b\n", 3)    // 11
fmt.Printf("%02b\n", 1&3)  // 01
Побітовий оператор ||
0 | 0 == 0
0 | 1 == 1
1 | 1 == 1
fmt.Printf("%02b\n", 2)    // 10
fmt.Printf("%02b\n", 0)    // 00
fmt.Printf("%02b\n", 2|0)  // 10
--------------------------------
fmt.Printf("%016b\n", os.O_RDONLY)     //  0000000000000000
fmt.Printf("%016b\n", os.O_WRONLY)     //  0000000000000001
fmt.Printf("%016b\n", os.O_RDWR)       //  0000000000000010
fmt.Printf("%016b\n", os.O_CREATE)     //  0000000001000000
fmt.Printf("%016b\n", os.O_APPEND)     //  0000010000000000
--------------------------------
fmt.Printf("%016b\n", os.O_WRONLY|os.O_CREATE)               //  0000000001000001
fmt.Printf("%016b\n", os.O_WRONLY|os.O_CREATE|os.O_APPEND)   //  0000010001000001

fmt.Println(os.FileMode(0700))
fmt.Println(os.FileMode(0070))
fmt.Println(os.FileMode(0007))
-rwx------  // власник файлу
----rwx---  // користувачі з групи
-------rwx  // всі інші
0    Разрешения отсутствуют
1    Исполнение
2    Запись
3    Запись, исполнение
4    Чтение
5    Чтение, исполнение
6    Запись, чтение
7    Запись, чтение, исполнение

if count := 5; count > 4 {
	fmt.Println("count is", count)
}

Если же вы хотите, чтобы после текущей секции
case выполнялся код следующей, для этого существу-
ет ключевое слово fallthrough

Если вас интересует длина строки в символах, используйте функцию
RuneCountInString из пакета unicode/utf8
fmt.Println(utf8.RuneCountInString(asciiString))
fmt.Println(utf8.RuneCountInString(utf8String))

channel := make(chan string, 3)
Когда горутина отправляет значение в небуферизованный канал, она немедленно
блокируется до того, как значение будет получено другой горутиной. С другой
стороны, буферизованные каналы могут вмещать определенное количество зна-
чений, прежде чем отправляющая горутина будет заблокирована. В подходящей
ситуации это может улучшить быстродействие программы.

channel := make(chan string, 2)
Чтобы немного ускорить выполнение программы, можно добавить в канал буфера еще одно значение.
Для этого достаточно добавить второй аргумент при вызове make. В остальном взаимодействия с
каналом остаются неизменными, так что вносить другие изменения в код не придется.
Теперь когда горутина sendLetters отправит свое первое значение в канал, она не блокируется
до того момента, как это значение будет получено горутиной main. Отправленное значение вместо
этого попадает в буфер канала. Только при отправке второго значения (при том, что ни одного
значения еще не было получено) буфер канала заполняется, а горутина sendLetters блокируется.
Добавление буфера, рассчитанного на одно значение, сокращает время выполнения программы на 1 секунду.


Функция init выполняется при инициализации пакета


пакет (файл) redis імпортується в пакет (файл) main.
значить перше виконається init() в redis потім init() в main


щоб ініціалізувати пакет (файл) без імпорту з нього, потрібно вписати _
import (
"fmt"
_ "foo"
)


Інтерфейсти відділяють код від його реалізації
Якщо ми покладаємось на абстрацію, замість конкретної реалізації, то сама реалізація може бути замінена на іншу без заміни коду.
Це і є принцип Лісков


краше повертати з функцій конкретні реалізації а не інтерефейси


Щоб написати функцію в го яка приймає любий тип потрібно використати пустий Інтерфейс
func printValue(v interface{}) {
    fmt.Println(v)
}


Ключем в map в го може бути тип який можна порівнювати за допомогою операторів рівності (== і !=)
Це означає, що типи, які задовольняють обмеженню comparable, можуть бути використані як ключі в мапах
Типи, які є comparable:
	Всі базові типи, такі як int, float, string, bool.
	Вказівники.
	Масиви, якщо їх елементи є comparable.
	Структури, якщо всі їх поля є comparable.
Типи, які не є comparable:
	Слайси.
	Мапи.
	Функції.


Дженерік
func foo[T any](t T) {
    fmt.Println(t)
}
func main() {
    foo(42) // T буде визначено як int
}
Отже, [T any] визначає, що T може бути будь-яким типом, і дозволяє функції foo приймати аргументи будь-якого типу.


Якщо функція має приймати map яка може мати любі типи, то тоді треба дженерів для K,V
func getKeys[K comparable, V any](m map[K]V) []K {
    var keys []K
    for k := range m {
        keys = append(keys, k)
    }
    return keys
}


x := map[int]string{1: "one", 2: "two"}
==
var x map[int]string
x = map[int]string{1: "one", 2: "two"}


кастомний тип замість constrain
type customConstraint interface {
	~int | ~string
}
func getKeys[K customConstraint, V any](m map[K]V) []K {
	// Та же реализация
}


constraint
~int і int?
~int ограничивает все типы, базовым типом которых является int


Як добавити обмеження типу
func constrainMe interface {
	~int   // всі пити базовим типом яких є int
	String() string    // реалізує метод String()
}
type customInt int  // значить це відповідає інтерфейсу constrainMe
func (i customInt) String() string {  // тут ми реалізуємо тип String() який повертає рядок
	return strconv.Itoa(int(i))
}
У підсумку, тип customInt реалізує інтерфейс constrainMe, оскільки він:
Сумісний з типом int (оскільки це новий тип на основі int).
Має метод String(), який повертає рядок.


Дженерики вводят некоторую форму абстракции
якось до того жили без них


type Foo struct {
	Bar  // Встроенное поле
}
type Bar struct {
	Baz int
}
foo := Foo{}
foo.Baz = 42
Якщо поле вбудоване то до нього буде доступ ззовні
Щоб поле було заблоковано ззовні потрібно вказати тип


Параметри функцій
Go не підтримує параметри за замовчуванням, але є способи
///////////////////////////////////////////////////////////
func One(name string, message ...string){
	defaultMessage := "hello"
	if len(message) == 0 {
		fmt.Println("%s, %s!\n", defaultMessage, name)
	}
}
///////////////////////////////////////////////////////////
type One struct {
	name string
	age int
}

func X() *One{
	return &One{name: "Taras", age: 16}
}
func greetWithConfig(cfg *One) {
    fmt.Printf("%s, %s!\n", cfg.name, cfg.age)
}
func main() {
	a:= X()
	greetWithConfig(a)
}


Оператор * використовується для доступу до значення за адресою (розіменування вказівника)
Оператор & використовується для отримання адреси змінної (створення вказівника)


Структура проекту го
/cmd — основные исходные файлы. Файл main.go приложения foo должен находиться в /cmd/foo/main.go.
/internal — закрытый (private) код: мы не хотим, чтобы другие импортировалиего для своих приложений или библиотек
/pkg — общедоступный (public) код, который мы хотим предоставлять другим в пользование.
/test — дополнительные внешние тесты и тестовые данные
/configs — файлы конфигурации.
/docs — проектные и пользовательские документы
/examples — примеры для нашего приложения и/или общедоступной библиотеки
/api — файлы контрактов API (Swagger, Protocol Buffers и т. д.)
/web — ресурсы, относящиеся к веб-приложению (статические файлы и т. д.).
/build — файлы упаковки и непрерывной интеграции (CI).
/scripts — скрипты для анализа, установки и т. д.
/vendor — зависимости приложений (например, зависимости модулей Go)


Варіантивна кількість параметрів
func greet(name string, messages ...string) {
    for _, message := range messages {
        fmt.Printf("%s, %s!\n", message, name)
    }
}
greet("Alice", "Hello", "Welcome", "Good to see you")
...string: Дозволяє передавати довільну кількість аргументів без необхідності створювати зріз.
[]string: Потребує створення зрізу перед передачею у функцію.


sum := 100 + 010
fmt.Println(sum)
В го (010) литерал, начинающийся с 0, считается восьмеричным
целым числом (то есть числом по основанию 8), поэтому 10 по основанию 8
равняется 8 по основанию 10. Таким образом, сумма в предыдущем примере
равна 100 + 8 = 108
Щоб відділити можна так 
0o644


int8: от -128 до 127
int16: от -32768 до 32767
int32: от -2147483648 до 2147483647
int64: от -9223372036854775808 до 9223372036854775807
int: размер зависит от архитектуры (обычно 32 или 64 бита)
uint8: от 0 до 255
uint16: от 0 до 65535
uint32: от 0 до 4294967295
uint64: от 0 до 18446744073709551615
uint: размер зависит от архитектуры (обычно 32 или 64 бита)
Если нужно проверить на переполнение переменную
типа int, можно сделать это с помощью math.MaxIntі


Python автоматично переходить з використання звичайних цілих чисел (зазвичай 32 або 64 біти)
на використання довгих цілих чисел (arbitrary-precision integers)
Python є мовою з динамічною типізацією, що означає, що типи змінних визначаються під час виконання,
а не під час компіляції. Це дозволяє Python автоматично змінювати тип змінної з int на long (у Python 2)
або використовувати єдиний int тип (у Python 3), який підтримує довгі цілі числа.


IEEE-754, NaN — единственное число с плавающей точкой, удовлетворяющее условию f ! = f.


Go-разработчики довольно часто путают понятия длины среза и его емкости
В Go за срезом стоит массив
Длина — это количество элементов, содержащихся в срезе, тогда
как емкость — это количество элементов в резервном массиве.
s := make([]int, 3, 6)
Срез длиной 3 и емкостью 6
В данном случае make создает массив из шести элементов (емкость). Но посколь-
ку длина среза была задана равной 3, то Go инициализирует только первые три
элемента. Кроме того, поскольку срез является типом []int, первые три элемента
инициализируются нулевым значением int: 0. Для элементов, обозначенных
серым цветом, память зарезервирована, но они пока не используются.
Как использовать оставшееся пространство среза? С помощью встроенной
функции append:
s = append(s, 2)
В Go размер среза будет удваиваться до тех пор, пока
он не станет содержать 1024 элемента, после чего будет увеличиваться
на 25 %.
Go внутри себя создает другой массив, удваивая его емкость
и копируя в него все элементы, а затем вставляет новий элемент


s1 := make([]int, 3, 6)
s2 := s1[1:3]
Срезы s1 и s2 ссылаются на один и тот
же резервный массив, но с разной длиной
и емкостью

Поскольку за s1 и s2
стоит один и тот же массив,
обновление общего элемента
делает изменение видимым
в обоих срезах

s: [0 0 0], len: 3, cap: 5
s: [0 0 0 1], len: 4, cap: 5
s: [0 0 0 1 2], len: 5, cap: 5
s: [0 0 0 1 2 3], len: 6, cap: 10
В начале мы создаем срез s с длиной 3 и емкостью 5.
Емкость 5 означает, что срез может содержать до 5 элементов без перераспределения памяти.
Когда мы добавляем четвертый и пятый элементы, длина увеличивается, но емкость остается прежней.
Когда мы добавляем шестой элемент, текущая емкость (5) превышена, и Go перераспределяет память,
удваивая емкость до 10, чтобы вместить дополнительные элементы.


Длина среза — это количество доступных элементов в нем, 
емкость среза — это количество элементов в резервном массиве
Якщо ми задаємо ємність то при добавленні нових елементів не будуть створюватись резервні Масиви



Срез считается пустым, если его длина равна 0.
Срез считается нулевым, если его значение равно nil.
варіанти створення зрізів
var s []string
s = []string(nil)
s = []string{}
s = make([]string, 0)
1: empty=true nil=true
2: empty=true nil=true
3: empty=true nil=false
4: empty=true nil=false
Здесь нулевой срез маршалируется как элемент null,
тогда как ненулевой пустой срез маршалируется как пустой массив
Нулевой срез равен nil, тогда как пустой срез имеет нулевую длину.
Нулевой срез пуст, но пустой срез не обязательно равен nil.


var s []string, если нет определенности в отношении конечной длины и срез
может быть пустым


[]string(nil) как синтаксический сахар для создания нулевого и пустого
среза.


make([]string, length), если будущая длина известна.


Найправильніший спосіб перевірити чи зріз чи він пустий чи нульовий це len


Як копіювати один зріз в другий
src := []int{0, 1, 2}
var dst []int
copy(dst, src)
fmt.Println(dst)  // []  вийде пустий зріз тому що dst має довжину 0. А при copy береться найменше з (3 i 0)


Як копійнути правильно
src := []int{0, 1, 2}
dst := make([]int, len(src))
copy(dst, src)
Альтернатива copy
src := []int{0, 1, 2}
dst := append([]int(nil), src...)


Якщо в нас є зріз на 1млн елементів а ми хочемо показувати тільки останні 5, то потрібно
msgType := make([]byte, 5)
copy(msgType, msg)
Але все таки повний зріз теж не можна брати бо вихідний масив все ще буде в пам'яті
 качестве эмпирического правила запомните, что нарезка большого среза
или массива может потенциально привести к высокому потреблению памяти
Использование копии среза — это
способ предотвращения такой ситуации



как работают операторы == и !=. Со срезами или картами они не работают вообще
можно использовать Reflect.DeepEqual
Эта функция сообщает, являются ли два элемента глубоко равными (deeply equal),
рекурсивно обходя два значения
Reflect.DeepEqual примерно в 100 раз медленнее, чем ==

accounts := []account{
{balance: 100.},
{balance: 200.},
{balance: 300.},
}
	for _, a := range accounts {
		a.balance += 1000  // не обновить значення тому що створюються копії
}
for i := range accounts {
	accounts[i].balance += 1000  // обновить значення нормально
}
for i := 0; i < len(accounts); i++ {
	accounts[i].balance += 1000  // обновить значення нормально
}




карти
m := make(map[string]int, 1_000_000)
Створення дікта на 1млн елементів
Якщо вставити 1млн ел в карту без розміру і з розміром заданим
То останінй варіант буде на 60% швидший



Якщо створити карту добавити 1 млн ел, а потім видалити їх
То память не очиститься в нуль так як сегменти залишаться
При видалені елементів обнуляються слоти в сегментах, але самих сегментів не стає менше


Якщо створити карту через вказівники масиву
                        					map[int][128]byte vs map[int]*[128]byte
Создание пустой карты                              0                    0
Добавление 1 миллиона элементов                    461mb               182mb
Удаление всех элементов и исполнение GC           293mb                 38mb


Если ключ или значение превышает 128 байт, Go не будет
хранить их непосредственно в сегменте карты. Вместо этого хранится указа-
тель — для ссылки на ключ или на значение.


map[int][128]byte:
Це карта, де кожен ключ (типу int) мапується на значення типу [128]byte.
Всі значення зберігаються в самій мапі.
Коли ви додаєте або змінюєте елемент у мапі, Go копіює всі 128 байт.


map[int]*[128]byte:
Це карта, де кожен ключ мапується на вказівник (pointer) на масив з 128 байтів.
Вказівники на масиви зберігаються в мапі, а самі масиви знаходяться в пам'яті.
Це економить місце у мапі, оскільки зберігаються лише вказівники (по 8 байт на 64-бітових системах).
Копіювання значень займає менше часу, оскільки копіюються лише вказівники, а не самі дані масивів.


Зберігання вказівника займає 8 байт на 64 і 4 байта на 32


s := []int{0, 1, 2}
for range s {
	s = append(s, 10)
}
такий цикл завершиться після 3х ітерацій
В этом контексте слово «вычисляется» означает, что предоставленное выражение
копируется во временную переменную, а затем цикл range выполняет итерации
над этой переменной.



s := []int{0, 1, 2}
for i := 0; i < len(s); i++ {
	s = append(s, 10)
}
Значение выражения len(s) вы-
числяется во время каждой итерации, и раз мы продолжаем добавлять элемен-
ты, то никогда не достигнем состояния завершения цикла


& (Оператор взяття адреси):
Оператор & використовується для отримання адреси змінної
* (Оператор розіменування):
Оператор * використовується для доступу до значення за адресою



Щоб зробити параметри який може бути або string або nill потрнібно використовувати вказівник на string
func processString(s *string) {
	if s == nil {
		fmt.Println("Received nil")
	} else {
		fmt.Println("Received string:", *s)
	}
}
func main() {
	str := "Hello, Go!"
	var nilStr *string = nil

	processString(&str)  // Passing a string
	processString(nilStr) // Passing nil
}


типы типизации
Номинальная типизация.
Номинальная типизация подтипов.
Структурная типизация.


Вместо иерархий типов в Go мы используем интерфейсы и структурную типизацию.

Полиморфизм — это принцип, который позволяет использовать один и тот же интерфейс для работы с различными
типами данных или объектами, обеспечивая выполнение одной и той же операции или функции с
разными типами входных данных.


Типи поліморфізму
Параметрический полиморфизм.
Ad-hoc полиморфизм.
Полиморфизм подтипов.


Параметрический полиморфизм — это дженерики


Ad‑hoc полиморфизм — это, по сути, интерфейсы. «Программируйте на уровне интерфейса, а не на уровне реализации».
Это также перегрузка методов или функций, но этого в Go уже нет. Точнее, не доступно при написании собственного
кода, но создатели языка активно это использовали. Например, встроенная функция make(). Вы можете передавать
туда разные типы и количество аргументов, и в зависимости от этого она адаптирует своё поведение. Или, другими
словами, перегружается.
mySlice := make([]int, 5) // Создание слайса типа int длиной 5 элементов
myMap := make(map[string]int) // Создание map с ключами типа string и значениями типа int
myChannel := make(chan int) // Создание канала для передачи данных типа int


А вот полиморфизма подтипов в Go нет.
Полиморфизм подтипов — это принцип программирования, который позволяет использовать объекты совместимых типов вместо объектов
базового типа в любом контексте, где ожидается базовый тип, при этом сохраняется корректное выполнение программы.



package main

func ProcessPaymentMasterCard(mcp masterCardPayment, amount float64) (string, error) {
	return mcp.PayByMasterCard(amount)
}

func ProcessPaymentVisa(vp visaPayment, amount float64) (string, error) {
	return vp.PaByVisa(amount)
}


Мы могли бы пойти вот таким путём: наплодить кучу отдельных функций, которые были бы завязаны на конкретные структуры.
То есть каждая из processPaymentMasterCard и processPaymentVisa зависела бы от конкретной, не абстрактной реализации конкретной структуры.
В нашем примере мы сразу проскочили этот этап и сделали всё по уму.

Мы захотели сделать наш код открытым для расширения и закрытым для изменения в соответствии с
SOLID → мы применили паттерн «Стратегия» → паттерн «Стратегия» буквально основывается на принципе
инверсии зависимостей из SOLID → а сама инверсия зависимостей тесно связана с внедрением зависимости
(Dependency Injection).

Dependency Injection, вы можете увидеть сам процесс внедрения в теле функции main.
Там мы инициализируем наши структуры и передаём их внутрь processPayment — это и есть те самые
внедряемые зависимости, которые ждёт эта функция. Внедрение зависимости в общем случае — штука
довольно банальная. К примеру, в том же функциональном программировании само это понятие даже
избыточно, так как там функции повсеместно принимают другие функции в качестве аргументов, что
по сути и является тем же Dependency Injection.


func ProcessPaymentMasterCard(mcp masterCardPayment, amount float64) (string, error) {
	return mcp.PayByMasterCard(amount)
}

func ProcessPaymentVisa(vp visaPayment, amount float64) (string, error) {
	return vp.PaByVisa(amount)
}

// Мы могли бы пойти вот таким путём: наплодить кучу отдельных функций,
// которые были бы завязаны на конкретные структуры.
// То есть каждая из processPaymentMasterCard и processPaymentVisa
// зависела бы от конкретной, не абстрактной реализации конкретной структуры.

// Мы захотели сделать наш код открытым для расширения и закрытым для
// изменения в соответствии с SOLID → мы применили паттерн «Стратегия»
// → паттерн «Стратегия» буквально основывается на принципе инверсии
// зависимостей из SOLID → а сама инверсия зависимостей тесно связана
// с внедрением зависимости (Dependency Injection)

// Говоря о Dependency Injection, вы можете увидеть сам процесс внедрения
// в теле функции main. Там мы инициализируем наши структуры и передаём их
// внутрь processPayment — это и есть те самые внедряемые зависимости,
// которые ждёт эта функция. Внедрение зависимости в общем случае — штука
// довольно банальная. К примеру, в том же функциональном программировании
// само это понятие даже избыточно, так как там функции повсеместно принимают
// другие функции в качестве аргументов, что по сути и является тем же
// Dependency Injection.


Щоб звернутись не до копії масиву а до самого масиву в го
Потрібно його вказувати через індекс
a:=[3]int{1,2,3}
for i:=range a {
	a[2] = 10
	if i == 2 {
		fmt.Println(a[2])
	}
}
або використати вказівник (тут виграш тому що не йде копіювання масиву)
func main() {
	a := [3]int{1, 2, 3}
	for _, v := range &a {
		a[2] = 10
		fmt.Println(v)
	}
}


В карті го немає порядку елементів


Когда элемент добавляется к карте во время итерации, он может быть либо
создан, либо нет при последующей итерации. В Go нет возможности как-то «на-
вязать» поведение кода. Оно может варьироваться от одной итерации к другой,
и поэтому мы трижды получали разные результаты.



break завершает выполнение самого последнего оператора for, switch или select.
Якщо break вкладений в switch всередині for - то перерветься for


loop:  // мітка
	for i := 0; i < 5; i++ {
	fmt.Printf("%d ", i)
	switch i {
		default:  //  є стандартним випадком, який буде виконаний, якщо жоден з інших випадків не спрацює
		case 2:
			break loop  // тепер оцей break перерве мітку loop
		}
	}
loop: — це мітка, яка позначає початок циклу. Мітки в Go використовуються для позначення місць у коді,
до яких можна звертатися з командами break або continue. Це дозволяє вийти з вкладених циклів або перейти
до певного місця в коді.
Поэтому прерывание действия оператора с помощью меток — это идиоматический подход в Go


Можно использовать continue с меткой, чтобы перейти к следующей итерации отмеченного цикла.


defer всередині циклу не виконується на кожній ітерації
Щоб defer виконувався під час кожної ітерації потрібно:
вкласти defer всередину чогось


Значение элемента, по которому проводится цикл range, является копией.
Поэтому чтобы изменить структуру, обращайтесь к ней, например, через ее
индекс или используйте классический цикл for (если только элемент или
поле, которые вы хотите изменить, не являются указателем).


Понимание того, что выражение, переданное оператору range, вычисляется
только один раз перед началом цикла, поможет избежать неэффективного
присваивания в итерации по каналу или срезу.


Чтобы обеспечить предсказуемость результатов при использовании карт,
помните, что эта структура данных:
• не упорядочивает данные по ключам;
• не сохраняет порядок их вставки;
• не имеет детерминированного порядка итерации;
• не гарантирует, что элемент, добавленный во время итерации, будет создан во время этой итерации.


###########################################   РУНИ   ###########################################


В Go строка — это неизменяемая структура данных, содержащая:
указатель на неизменяемую последовательность байтов;
общее количество байтов в этой последовательности


Кодирование — это перевод списка символов в двоичный код. Например,
UTF-8 — это стандарт кодирования, определяющий способ того, как воз-
можно закодировать все символы Unicode в переменном количестве байтов
(от 1 до 4 байт).


Кодировка символов — это набор символов.


Go руна — это кодовая точка Unicode
Go руна — это псевдоним типа int32


s := "汉"
fmt.Println(len(s)) // 3  тобто символ кодується 3ма байтами


len возвращает количество байтов в строке, а не количество рун


s := "hêllo"  // Литерал строки содержит специальную руну — ê.
for i := range s {
	fmt.Printf("position %d: %c\n", i, s[i])
}
fmt.Printf("len=%d\n", len(s))  // виведе 6 (кількість байт) тому що руна ê закодована 


щоб вивести саме ê потрібно не індекс а значення
s := "hêllo"
for i, r := range s {
	fmt.Printf("position %d: %c\n", i, r)
}


або можна перетворити строку на срез рун и итерации по нему
преобразование строки в срез рун требует выде- ления места в памяти для
дополнительного среза и преобразования байтов
в руны: временная сложность O(n), где n — количество байтов в строке.
s := "hêllo"
runes := []rune(s)
for i, r := range runes {
	fmt.Printf("position %d: %c\n", i, r)
}


Если строка состоит из однобайтовых рун, то возможен один метод оптимизации:
например, когда строка содержит буквы от A до Z и от a до z. Мы можем полу-
чить доступ к i-й руне без преобразования всей строки в срез рун, обратившись
к байту напрямую с помощью s[i]:
s := "hello"
fmt.Printf("%c\n", rune(s[4])) // o


TrimRight и TrimSuffix
fmt.Println(strings.TrimRight("123oxo", "xo")) -> 123
TrimRight удаляет все завершающие руны, содержащиеся в заданном множестве.
123oxo
o является частью множества, удалить
x является частью множества, удалить
o является частью множества, удалить
3 НЕ является частью множества, останов
TrimRight перебирает каждую руну в обратном порядке. Если руна является
частью предоставленного множества, то функция удаляет ее, если нет, то оста-
навливает итерации и возвращает оставшуюся строку. Вот почему наш пример
возвращает 123.



TrimSuffix возвращает строку без указанного завершающего
суффикса:
fmt.Println(strings.TrimSuffix("123oxo", "xo")) -> 123o


2 способи конкантенації string
func concat(values []string) string {
	s := ""
	for _, value := range values {
		s += value
	}
	return s
}
Строки незмінні тому кожного разу буде створюватись нова строка в пам'яті


Для того щоб не заповнювалась пам'ять є вбудована штука
func concat(values []string) string {
	sb := strings.Builder{}
	for _, value := range values {
		_, _ = sb.WriteString(value)
	}
	return sb.String()
}


strings.Builder будет быстрее с того момента, когда нужно будет объединять более пяти строк.


Як повернути справжню довжину строки в го
func main() {
    str := "こんにちは" // Japanese for "Hello"
    byteLen := len(str)
    fmt.Println("Number of bytes:", byteLen)
    runeLen := len([]rune(str))
    fmt.Println("Number of characters:", runeLen)
}


Итерация строки с помощью range выполняет итерацию по рунам с индексом,
соответствующим начальному индексу последовательности байтов руны.
Чтобы получить доступ к определенному индексу рун (например, к третьей
руне), преобразуйте строку в []rune.


Конкатенация списка строк должна выполняться с помощью strings.
Builder, чтобы предотвратить резервирование места в памяти для новой
строки во время каждой итерации

################################################################################################

##########################################   ФУНКЦІЇ  ##########################################


Функция оборачивает последовательность инструкций в модуль, который может быть вызван в другом месте.
func (c *customer) add(operation float64) {}
Получатель должен быть указателем:
- Если метод должен изменить получатель
- Если получатель — крупный объект
Получатель должен быть значением:
- Если нужно обеспечить неизменность получателя.
- Если получателем является карта, функция или канал. Иначе возникнет ошибка при компиляции.
- Если получатель является базовым типом — int, float64 или string.
// Метод с получателем типа map вызовет ошибку компиляции
func (m map[string]int) Print() {
    fmt.Println(m)
}


################################################################################################
Якщо не вказати що повертає return то він поверне те що в (b int)


func f(a int) (b int) {
	b = a
	return
}

################################################################################################

не потрібно писати в функціях ім'я файлу для читання
тому що при тестуванні нам треба буде створювати багато різних файлів
треба робити більш абстрактной
(reader io.Reader)
буде підходити як і до файла 
так і до http запиту

################################################################################################

func xxx(x string) {
	fmt.Printf("I am %s\n", x)
}

func main() {
	var x string
	defer xxx(x) // аргументи defer вираховуються зразу тому завжди буде пуста строка
	x = "alamo"
	fmt.Println(x)
}


Пофіксити варіант 1 передати вказівник
func xxx(x *string) {
	fmt.Printf("I am %s\n", *x)
}

func main() {
	var x string
	defer xxx(&x) // аргументи defer вираховуються зразу тому завжди буде пуста строка
	x = "alamo"
	fmt.Println(x)
}

Пофіксити варіант 2 використати замикання
При замиканні xxx посилається на змінну ззовні тому x = alamo виконається після замикання а не під час defer
func main() {
	var x string
	defer func() {
		xxx(x) // 
	}()
	x = "alamo"
	fmt.Println(x)
}

################################################################################################

panic - зупинає потік виконання

паніку можна перехопити в recover

паніка перехоплюється тільки в defer інакше поверне nil

func main() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("Recovered from panic:", r)
		}
	}()

	fmt.Println("Starting the program")

	// This will cause a panic
	causePanic()

	fmt.Println("This line will not be reached")
}

func causePanic() {
	fmt.Println("About to panic")
	panic("Something went wrong!")
}

################################################################################################

Як обробляти помилки

1.
if err != nil {
	return err        Если мы не хотим ее пометить и понимаем, что нет какого-либо полезного контекста
}

2.
if err != nil {
	return fmt.Errorf("bar failed: %w", err)    Этот код оборачивает исходную ошибку, чтобы можно было добавлять дополнительный контекст
}


if err != nil {
	return fmt.Errorf("bar failed: %v", err)         тут помилка не обертається а просто перетворюється в іншу щоб ми могли добавити щось до неї
}

| Вариант/случай                | Дополнительный контекст                                    | Пометка              | Ошибки                                           | Исходная ошибка доступна?  | Возврат ошибки напрямую  |
|-------------------------------|------------------------------------------------------------|----------------------|--------------------------------------------------|----------------------------|--------------------------|
| Возврат ошибки напрямую        | Нет                                                       | Нет                  | Да                                               | Нет                        | Да                       |
| Пользовательский тип ошибки    | Возможен (если тип ошибки содержит строковое поле)        | Да                   | Возможно (если исходная ошибка экспортируется    | Да                         | Возможно (если исходная  |
|                                |                                                           |                      | или доступна через метод)                        |                            | ошибка экспортируется    |
|                                |                                                           |                      |                                                  |                            | или доступна через метод)|
| fmt.Errorf с %w                | Да                                                        | Нет                  | Да                                               | Да                         | Да                       |
| fmt.Errorf с %v                | Да                                                        | Нет                  | Нет                                              | Нет                        | Нет                      |

################################################################################################

Переменная GOMAXPROCS определяет предел количества потоков M,
отвечающих за одновременное исполнение кода пользовательского уровня.
Начиная с Go 1.5, GOMAXPROCS по умолчанию равен количеству доступных ядер CPU
среда выполнения Go может создать больше потоков ОС, чем значение GOMAXPROCS

################################################################################################

синхронизация между параллельными горутинами должна достигаться с помощью мьютексов
для параллельных горутин нужны мьютексы, а для конкурентных каналы

################################################################################################
гонки данных

запустить этот код с использованием детектора гонок Go (опция -race)

Первый вариант — сделать операцию инкремента атомарной, то есть выполняемой целиком за один шаг
var i int64
go func() {
	atomic.AddInt64(&i, 1)  // Атомарное увеличение значения i

}()
go func() {
	atomic.AddInt64(&i, 1)  // То же самое
}()
пакет sync/atomic
работает только с определенными типами данных. Если нужно обрабатывать
данные каких-то других видов (например, срезы, карты или структуры), то мы
не можем полагаться на sync/atomic


Другой вариант — синхронизировать две горутины с помощью специальной
структуры данных, мьютекса. Слово мьютекс (mutex) образовано от «mutual
exclusion», что означает «взаимное исключение»

i := 0
mutex := sync.Mutex{}
go func() {
	mutex.Lock()  // 		Начало критического раздела
	i++  // 		Увеличение значения i на единицу
	mutex.Unlock()  // 		Конец критического раздела
}()
go func() {
	mutex.Lock()
	i++
	mutex.Unlock()
}()

Другой возможный вариант — запретить совместное использование одного и того
же места в памяти и отдать предпочтение взаимодействию между горутинами.
Например, создать канал, который каждая горутина использует для получения
значения инкремента:

i := 0
ch := make(chan int)
go func() {
	ch <- 1  // Уведомление горутины об увеличении на 1
}()
	go func() {
ch <- 1
}()
i += <-ch  // Увеличение i от того ее значения, которое было получено из канала
i += <-ch

- использование атомарных операций;
- защита критических секций с помощью мьютексов;
- использование связи и каналов для обеспечения того, чтобы переменнаяобновлялась только одной горутиной.

состояние гонки - когда поведение зависит от последовательности или времени выполнения событий, которые невозможно контролировать

################################################################################################

через очікування значення з каналу можна заблокувати горутину
а закриття каналу розблокує горутину котра очікує чогось

этот пример также свободен от гонки данных

i := 0
ch := make(chan struct{})
go func() {
	<-ch  // blocking operation. It means the goroutine will pause at this line until something is sent to ch or the channel is closed
	fmt.Println(i)
}()
i++
close(ch)  // effectively unblocks the waiting goroutine


################################################################################################

i := 0
ch := make(chan struct{}, 1)  // тут канал буферизований тому буде гонка
go func() {
	i = 1
	<-ch
}()
ch <- struct{}{}
fmt.Println(i)

vs

i := 0
ch := make(chan struct{})  // канал небуферизований - гонки не буде
go func() {
	i = 1
	<-ch
}()
ch <- struct{}{}
fmt.Println(i)

################################################################################################

Типи робочих нагрузок

Тактовой частотой/скоростью работы центрального процессора
это главный фактор при выполнении алгоритма сортировки слиянием
CPU-bound

Скоростью работы системы ввода/вывода: например, это главный фактор
при выполнении вызова REST или запроса к базе данных
I/O-bound

Объемом доступной памяти (рідкісна штука так як пам'ять дешева)
memory-bound

################################################################################################

ctx context.Context

коли використовується контекст
- incoming requests
- outgoing requests

net
database/sql

нащо потрібен контекст
- передати сигнал на відміну і deadline
- передавати request-scoped values

- спосіб доставки повідомлень що потрібно щось завершити
- на рівні middleware записати в контекст токен і потім на кінцевих хендлерах не парсити токен його можна витягнути з контексту

package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	ctx, cancel := context.WithCancel(context.Background())  // Створює новий контекст, який можна скасувати, викликавши функцію cancel
	                                                         // context.Background() -> базовий контекст - заглушка
	go func() {
		// Скасовуємо операцію через 2 секунди
		time.Sleep(2 * time.Second)
		cancel()   // В окремій горутині через 2 секунди викликається функція cancel, яка скасовує операцію.
	}()

	doSomething(ctx)
}

func doSomething(ctx context.Context) {
	select {
	case <-time.After(5 * time.Second):
		fmt.Println("Operation completed")
	case <-ctx.Done():
		// ctx.Done() канал сповіщає про скасування контексту
		fmt.Println("Operation canceled111:", ctx.Err())  // // Оскільки ми скасовуємо операцію через 2 секунди, функція виведе:
	}
}

Контекст допомагає зберігати контроль над тривалістю операцій і дозволяє зупинити їх за необхідності,
що особливо корисно у великих розподілених системах.


################################################################################################

263