WIN
set GOPATH="C:\code"

UNIX
export GOPATH="/code"

go clean -modcache

go mod tidy

go get ____________

go mod init xxx

godoc -http=:6060  # сервер з документацією локальний
http://localhost:6060/pkg


По умолчанию рабочей областью является каталог
с именем go в домашнем каталоге пользователя.

Чтобы использовать в качестве рабочей обла-
сти другой каталог, настройте переменную среды
GOPATH

Команда go install компилирует код пакета
и сохраняет его в каталоге pkg для пакетов общего
назначения или в каталоге bin для исполняемых
программ.

go install average
скомпілює наш main.go файл і закине його в папку bin
C:\Users\codeo\go\bin
Потім ми його можемо запустити з cmd
PS C:\Users\codeo\go\bin> .\average.exe
72.5


загон з шляхами
C:\Projects\golang\src\github.com\headfirstgo\average\main.go
в тому файлику була лінійка
numbers, err := datafile.GetFloats("C:/Projects/golang/src/github.com/headfirstgo/datafile/data.txt")
Я вписав абсолютний шлях
тому що коли робиш go install src/github.com/headfirstgo/average 
воно створювало exe файл в C:\Users\codeo\go\bin
і коли запускав його воно викидувало 2024/04/13 16:58:12 open ../datafile/data.txt: The system cannot find the path specified.
воно походу шукало data.txt на відносно того exe файлу ../datafile/data.txt
тобто раз вгору там datafile/data.txt
тому вписав абсолютний шлях

щоб використати slice заміть змінної кількості артгументів потрібно ...
func average(numbers ...float64) float64 {}
var numbers []float64
average(numbers...)

аналог dict в go
var ranks map[string]int  // оголошення //string - ключи,  int - значення
ranks := make(map[string]int)  // створення
myMap := map[string]float64{"a": 1.2, "b": 5.6}  // якщо літерат то make не треба

Якщо map оголошена але не створена то неможливо добавити якесь значення
var myMap map[int]string = make(map[int]string)
myMap[3] = "three"
А отак можливо

Якщо значення в мапі оголошене 0, а не присвоїне, то ok буде повертати false
counters := map[string]int{"a": 3, "b": 0}
value, ok := counters["a"]  // 3, true
value, ok := counters["c"]  // 0, false // звернення до відсутнього значення
_, ok = counters["f"] // перевірка на наявність значення

Видалення ключа
ranks := make(map[string]int)
ranks["bronze"] = 3
delete(ranks, "bronze")

map в go невпорядкований
тобто при ітерації церез map 
друкує кожен раз в різному порядку

якщо функція нічого не повертає, але треба модифікувати оригінальні дані 
то треба використовувати вказівники
а якщо функція повертає дані то не потрібні вказівники

fmt.Printf("%#v\n", subscriber.HomeAddress)
"%#v\n" виводить оригінальний вигляд
так як записано в коді
наприклад не пусте місце а пуста строка ""
але потрібно використовувати Printf а не Println

Якщо є анонімне поле
type Adress strunc {
    street string
}
type people struc {
    Adress
}
то можна упустити Adress при доступі до полів
а звертатись до street з people
people.street

Методи
ти параметра отримувача є типом з яким зв`язується Методи
type Words string
func (w Words) sayWords () {
    fmtw.Println(w)
}
a := Words("hello")
a.sayWords()
// w - параметр отримувача

w ім`я отримувача має бути першою буквою типу Words

Якщо є структура то її літерал буде з {}
coordinates := geo.Coordinates{}

В go дані інкапсулюються в пакетах
за допомогою неімпортованих імен (з малої букви)

якщо є структура з вбудованим типом
type MyStruct string
то вона викликається через круглі дужки
MyStruct("fffff")

Якщо немає panic то defer повертає nil
p := recover()
if p == nil {
    return
}

обробник паніки
func reportPanic() {
	p := recover()
	if p == nil {
		return
	}
	err, ok := p.(error)
	if ok {
		fmt.Println(err)
	} else {
		panic(p)
	}
}

справка по командах
go doc http Get
go doc http Response
go doc io ReadCloser
go doc ioutil ReadAll

створювалорення каналу
channelA := make(chan int)

Створити list
urls := []string{"https://example.com/", "https://golang.org/", "https://golang.org/doc"}


x:=[2]string{"one", "two"} vs x:=[]string{"one", "two"}
Passing to Functions: When you pass an array to a function, a copy of the entire array is made.
In contrast, passing a slice to a function only passes a reference to the underlying array,
which is more efficient for large data sets.

тести
якщо тести будуть в пакеті з кодом, то будуть мати доступ до неекспортуємих функцій
імена тестів повинні починатись з Test
тестові функції повинні мати 1 параметр (t *testing.T)

щоб тести запускались файл має називатись
_test.go
і тоді запуск через папку, а не через файл

go test .\compare\ -v
розширений вивід
go test .\compare\ -v -run First
запустить тести тільки ті які мають в імені First

